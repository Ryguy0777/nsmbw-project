#pragma once

#include <algorithm>
#include <memory>
#include <string_view>
#include <vector>

namespace std
{

template <
  class CharT, class Traits = std::char_traits<CharT>, class Allocator = std::allocator<CharT>>
class basic_string
{
public:
    // Type Aliases
    // ^^^^^^

    using traits_type = Traits;
    using value_type = CharT;
    using allocator_type = Allocator;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = typename std::allocator_traits<Allocator>::pointer;
    using const_pointer = typename std::allocator_traits<Allocator>::const_pointer;

public:
    // Structors
    // ^^^^^^

    constexpr basic_string(const allocator_type& alloc = allocator_type()) noexcept
      : m_vector(alloc)
    {
    }

    constexpr basic_string() noexcept(noexcept(allocator_type()))
      : basic_string(allocator_type())
    {
    }

    constexpr basic_string(
      size_type count, value_type ch, const allocator_type& alloc = allocator_type()
    ) noexcept
      : m_vector(count, ch, alloc)
    {
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    template <class InputIt>
    constexpr basic_string(
      InputIt first, InputIt last, const allocator_type& alloc = allocator_type()
    )
      : m_vector(first, last, alloc)
    {
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    constexpr basic_string(
      const value_type* s, size_type count, const allocator_type& alloc = allocator_type()
    )
      : m_vector(s, s + count, alloc)
    {
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    constexpr basic_string(const value_type* s, const allocator_type& alloc = allocator_type())
      : m_vector(alloc)
    {
        const size_type len = traits_type::length(s);
        m_vector.reserve(len);
        for (size_type i = 0; i < len; i++) {
            m_vector.push_back(s[i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    basic_string(std::nullptr_t) = delete;

    template <class StringViewLike>
    explicit constexpr basic_string(
      const StringViewLike& t, const allocator_type& alloc = allocator_type()
    )
    {
        const size_type len = t.size();
        m_vector.reserve(len);
        for (size_type i = 0; i < len; i++) {
            m_vector.push_back(t[i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    template <class StringViewLike>
    basic_string(
      const StringViewLike& t, size_type pos, size_type count,
      const allocator_type& alloc = allocator_type()
    )
    {
        const size_type len = t.size();
        if (pos > len) {
            // throw std::out_of_range("basic_string::basic_string");
            __builtin_trap();
        }
        const size_type rcount = std::min(count, len - pos);
        m_vector.reserve(rcount);
        for (size_type i = 0; i < rcount; i++) {
            m_vector.push_back(t[pos + i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    constexpr basic_string(const basic_string& other) = default;
    constexpr basic_string(basic_string&& other) = default;

    constexpr basic_string(const basic_string& other, const allocator_type& alloc)
      : m_vector(other.m_vector, alloc)
    {
    }

    constexpr basic_string(basic_string&& other, const allocator_type& alloc)
      : m_vector(std::move(other.m_vector), alloc)
    {
    }

    constexpr basic_string(
      const basic_string& other, size_type pos, const allocator_type& alloc = allocator_type()
    )
      : m_vector(alloc)
    {
        const size_type len = other.size();
        if (pos > len) {
            // throw std::out_of_range("basic_string::basic_string");
            __builtin_trap();
        }
        const size_type rcount = len - pos;
        m_vector.reserve(rcount);
        for (size_type i = 0; i < rcount; i++) {
            m_vector.push_back(other[pos + i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    constexpr basic_string(
      basic_string&& other, size_type pos, const allocator_type& alloc = allocator_type()
    )
      : m_vector(alloc)
    {
        const size_type len = other.size();
        if (pos > len) {
            // throw std::out_of_range("basic_string::basic_string");
            __builtin_trap();
        }
        const size_type rcount = len - pos;
        m_vector.reserve(rcount);
        for (size_type i = 0; i < rcount; i++) {
            m_vector.push_back(other[pos + i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    constexpr basic_string(
      const basic_string& other, size_type pos, size_type count,
      const allocator_type& alloc = allocator_type()
    )
    {
        const size_type len = other.size();
        if (pos > len) {
            // throw std::out_of_range("basic_string::basic_string");
            __builtin_trap();
        }
        const size_type rcount = std::min(count, len - pos);
        m_vector.reserve(rcount);
        for (size_type i = 0; i < rcount; i++) {
            m_vector.push_back(other[pos + i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

    constexpr basic_string(
      basic_string&& other, size_type pos, size_type count,
      const allocator_type& alloc = allocator_type()
    )
      : m_vector(alloc)
    {
        const size_type len = other.size();
        if (pos > len) {
            // throw std::out_of_range("basic_string::basic_string");
            __builtin_trap();
        }
        const size_type rcount = std::min(count, len - pos);
        m_vector.reserve(rcount);
        for (size_type i = 0; i < rcount; i++) {
            m_vector.push_back(other[pos + i]);
        }
        if (m_vector.size() == 0 || m_vector.back() != value_type()) {
            m_vector.push_back(value_type());
        }
    }

public:
    // Instance Methods
    // ^^^^^^

    constexpr size_type size() const noexcept
    {
        return m_vector.size() - 1;
    }

    constexpr const_pointer c_str() const noexcept
    {
        return m_vector.data();
    }

    constexpr const_pointer data() const noexcept
    {
        return m_vector.data();
    }

    constexpr pointer data() noexcept
    {
        return m_vector.data();
    }

    constexpr bool empty() const noexcept
    {
        return size() == 1;
    }

    constexpr void clear() noexcept
    {
        m_vector.clear();
        m_vector.push_back(value_type());
    }

    constexpr allocator_type get_allocator() const noexcept
    {
        return m_vector.get_allocator();
    }

public:
    // Operators
    // ^^^^^^

    constexpr const_reference operator[](size_type pos) const
    {
        return m_vector[pos];
    }

    constexpr reference operator[](size_type pos)
    {
        return m_vector[pos];
    }

    constexpr operator basic_string_view<value_type, traits_type>() const noexcept
    {
        return basic_string_view<value_type, traits_type>(data(), size());
    }

private:
    // Instance Variables
    // ^^^^^^

    std::vector<value_type, allocator_type> m_vector;
};

using string = basic_string<char>;

} // namespace std